# HelloWorld：

弹出框：

- alert("弹出框");

在页面中输出内容：

- document.write();

向控制台输出内容：

- console.log();

可以将js代码编写到标签的onclick属性中：

`<button onclick="alert('你点我啦！')">点我一下！</button>`

可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码

`  <a href="javascript:alert('让你点你就点啊！')">也点我以下</a>`

虽然可以写在标签的属性中，但是它们属于结合与行为耦合，不方便维护

JavaScript代码需要编写在<script></script>>中

- 可以将js代码编写到外部js文件中，然后通过script标签引入
- 写到外部文件中可以在不同的页面中同时引用，也可以利用浏览器的缓存机制
- script标签一旦引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略
- 如果需要则可以再创建一个新的script标签用于编写内部代码

# 基本语法：

//单行注释：注释内容不会被执行，但是可以在源代码中查看

/* 

多行注释：注释内容不会被执行，但是可以在源代码中查看

*/

- js中严格区分大小写
- js中每一条语句以分号结尾
  - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源
  - 而且有些时候，浏览器会加错分号，所以在开发中分号必须写

- js中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化

# 字面量和变量：

字面量：都是一些不可改变的值

- 字面量都是可以直接使用，但是我们一般不会直接使用字面量

变量：变量可以用来存储字面量，而且变量的值可以任意改变

- 变量更加方便我们使用，所以在开发中都时通过变量去保存一个字面量

声明变量：

- 在js中使用var关键字来声明一个变量
- 为变量赋值：var a = 666;

# 标识符：

在js中所有的可以由我们自主命名的都可以称为时标识符

- 例如：变量名、函数名、属性名都属于标识符
- 命名一个标识符需要遵守如下规则：
  - 标识符中可以含有字母、数字、_、$
  - 标识符不能以数字开头
  - 标识符不能时ES中的关键字或保留字
  - 标识符一般都采用驼峰命名法
    - 首字母小写，每个单词的开头字母大写，其余字母小写
    - 例如：helloWorld、xxxYyyZzz
- js底层保存标识符实际上时采用Unicode编码
- 所以理论上将，所有的utf-8中含有的内容都是可以作为标识符

![image-20210824175544518](https://github.com/Web-Wss/notes/blob/main/JavaScript/image-20210824175544518.png)

# 数据类型：

数据类型指的就是字面量的类型：

在js中一共由六种数据类型：

- string：字符串
- number：数值
- boolean：布尔值
- null：空值
- undefined：未定义
- object：对象

其中string、number、Boolean、null、undefined属于基本数据类型

而object属于引用数据类型

## string字符串：

- 在js中字符串需要使用引号引起来

- 使用双引号或单引号都可以，但是不要混着用
- 引号不能嵌套，双引号不能放双引号，单引号不能放单引号

在字符串中，我们可以使用转移转义字符“\”作为转移字符

当表示一些特殊符号时可以使用\进行转移

- \” 表示 ''
- \ ‘ 表示 '
- \n 表示换行
- \t  表示制表符

## number数值：

在js中所有的数值都是number类型

包括整数和浮点数（小数）

可以使用一个运算符typeof来检查一个变量的类型

- 语法：typeof 变量
  - 检查字符串时，会返回string
  - 检查数值时，会返回number

js中可以表示的数字的最大值和最小值

- Number.MAX_VALUE
- Number.MIN_VALUE

如果使用number表示的数字超过了最大值，则会返回一个infinity

- infinity 表示正无穷
- -infinity 表示负无穷

NaN 是一个特殊的数字，表示Not A Number

使用typeof检查一个NaN也会返回number

在js中整数的运算基本可以保证精确

如果使用js进行浮点元素计算，可能得不到一个精确的结果

所以千万不要使用js进行对精度要求比较高的运算

## Boolean布尔值：

布尔值只有两个，只要用来做逻辑判断

true：表示真

false：表示假

使用typeof检查一个布尔值时，会返回Boolean

## null和undefined：

null类型的值只有一个，就是null

null这个值专门用来表示一个空的对象

undefined类型的值只有一个，就是undefined

- 当声明一个变量，但是并不给变量赋值时，它就是undefined

使用typeof检查一个undefined时也会返回一个undefined

# 强制类型转换：

强制类型转换：

- 指将一个数据类型强制转换为其他的数据类型
- 类型转换主要指，将其他的数据类型，转换为string、number、Boolean

## 将其他的数据类型转换为string：

- 方式一：
  - 调用被转换数据类型的toString()方法
  - 该方法不会影响到原变量，它会将转换的结果返回
  - null和undefined这两个值没有toString()方法，调用会报错
- 方法二：
  - 调用String()函数，并且被转换的数据作为参数传递给函数
  - 使用String(0函数做强制类型转换时，number和Boolean实际上就是调用同String()方法
  - 对于null和undefined，就不会调用同String()方法
  - 会直接将null转换为“null”
  - 将undefined转换位“undefined”

## 将其他的数据类型转换为number：

- 方式一：

  - 使用number()函数
    - 字符串-->数字
      - 如果是纯数字的字符串，则直接将其转为数字
      - 如果字符串中有非数字的内容，则转为NaN
      - 如果字符串是一个空串或者是一个全是空格的字符，则转换为0
    - 布尔值-->数字
      - true转成1
      - false转为0
    - null-->数字：0
    - undefined-->数字：NaN

- 方式二：

  - 这种方式专门用来对付字符串
  - parseInt()：可以将一个字符串中有效的整数内容取出来，然后转为number
  - parseFloat()：和parseInt类似，取小数

  如果对非string使用parseInt()或parseFloat(),会先将其转换为string然后再操作

## 将其他的数据类型转换为boolean：

- 使用Boolean()函数来转换为boolean值
  - 数字-->布尔
    - 除了0和NaN，其余都是true
    - 除了空串，其余都是true
    - null和undefined都会转为false
    - 对象也会转换为true

# 其他进制的数字：

- 再js中，如果需要表示16进制的数字，则需要以0x开头
- 如果表示8进制的数字，则需要以0开头
- 如果表示2进制的数字，则需要以0b开头（不是所有的浏览器都支持）

可以再parseInt（）中传递一个第二个参数，表示进制

# 运算符：

运算符也叫操作符

通过运算符可以对一个或多个值进行运算

比如：typeof就是运算符，可以来获取一个值的类型

它会将该值的类型以字符串的形式返回

## 算数运算符：

当对非number进行运算时，会将这些值转换为number然后运算

任何值和NaN运算，结果都是NaN

+：

- +可以对两个值进行加法运算，并返回结果
- 如果对两个字符串进行相加时，会做拼接操作
- 任何的值和字符串做加法运算，都会转换为字符串，然后拼接
  - 我们可以利用这一特点，来将任意的数据类型转换为string，加一个“”即可

-：

- -可以对两个值进行相减运算，并返回结果

*：

- 可以对两个值进行乘法，并返回结果

/：

- 可以对两个值进行除法，并返回结果

任何值做- * / 运算时都会自动转换为number

我们利用这一点做隐式类型转换

可以通过为一个值 -0、*1、/1来将其转为number

%：

- %取模运算（取余数）

# 一元运算符：

只需要一个操作数

+：正号：正号不会对数字产生任何影响

-：负号：负号可以对数字进行负号的取反

对于非number类型的值，它会将先转换为number，然后再运算

可以对一个其他的数据类型使用+，来将其转换为number

它的原理和number()函数一样

# 自增和自减：

自增 ++：

- 通过自增可以使变量在自身的基础上增加1

- 对于一个变量自增后，原变量的值会立即自增1

- 自增分两种：

  - 后++：a++
  - 前++：++a

  无论是a++和++a，都会立即使原变量的值自增1

  a++的值等于原变量的值（自增前的值）

  ++a的值等于原变量新值（自增后的值）

自减 --：

- 通过自减可以使变量在自身的基础上减1

- 自减分成两种：

  - 后--：a--
  - 前--：--a

  无论是a-- 和 --a，都会立即使原变量的值自减1

  不同的是a-- 和 --a的值不同

  a-- 是变量的原值（自减前的值）

  --a 是变量的新值（自减以后的值）

# 逻辑运算符：

与 &&：

- &&可以对符号两侧的值进行与运算并返回结果
- 运算规则：
  - 如果两个值都是true则返回true
  - 两个值中，只要有一个false就返回false
- js中与属于短路的与，第一个是false，则不会就行执行

或 ||：

- 只要有一个true，就返回true
- 第一个值为false，则会检查第二个
- 第一个值为true，则不再检查第二个

非 ！：

- ！可以用来对一个值进行非运算
- 所谓非运算就是值对一个布尔值进行取反操作
- true边false，false边true
- 如果对一个值进行两次取反，则值不变
- 如果对非布尔值进行，则会将其转换为布尔值，然后取反
- 可以为一个任意数据类型取两次反，来将其转换为布尔值
- 原理和boolean()函数一样

# 非布尔的与或运算：

与运算：

- 如果两个值都为true，则返回后边的
- 如果两个值中有false，则返回靠前的false

或运算：

- 如果第一个值为true，则直接返回第一个值
- 如果第一个值为false，则直接返回第二个值

# 赋值运算符：

=：可以将符号有责的值赋给符号左侧的变量

+=：a += 5 等价于 a = a + 5

-=：a -= 5  等价于 a = a - 5

*=：a -= 5  等价于 a = a * 5

/=：a -= 5  等价于 a = a / 5

%=：a -= 5  等价于 a = a % 5

# 关系运算符：

通过关系运算符可以比较两个值之间的大小关系

- 如果关系成立返回true，反之返回false
- 大于号> 
  - 判断符号左侧的值是否大于右侧的值
  - 如果关系成立，返回true，反之，返回false
- 大于等于>=
  - 判断符号左侧的值是否大于或等于右侧的值
  - 如果关系成立，返回true，反之，返回false
- 大于号< 
  - 判断符号左侧的值是否小于右侧的值
  - 如果关系成立，返回true，反之，返回false
- 大于等于<=
  - 判断符号左侧的值是否小于或等于右侧的值
  - 如果关系成立，返回true，反之，返回false

非数值的情况：

- 对于非数值进行比较时，会将其转换为数字然后比较
- 如果符号两侧的值都是字符串，不会将其转换为数字进行比较
  - 而是比较其字符编码（unicode），一位一位进行比较的

- 任何值和NaN做比较都是false

# Unicode编码表：

在字符串中使用转移字符\u转移

- \u四位编码
- 网页中使用&#编码，写的是十进制

# 相等运算符：

比较两个值是否相等，如果相等，返回true，反之，返回false

- 使用 == 来做相等运算
  - 当使用 == 来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同类型，然后进行比较
- undefined 衍生自 null
  - 所以这两个值做相等判断时，会返回true

NaN不和任何值相等，包括自身

- 可以通过isNaN()函数来判断一个值是否是NaN

不相等用来判断两个值是否不相等

- !=
- 不相等也会对变量进行自动的类型转换

===：

- 全等，用来判断两个值是否全等，它和相等类似，不同的是要检查类型

!==：

- 不全等。

# 条件运算符（三元运算符）：

语法：

- 条件表达式？语句一：语句二
  - 执行流程：条件运算符在执行时，首先对条件表达式进行求值
  - 如果为true，则执行语句1，反之执行语句2

# 运算符优先级：

逗号  运算符

- 使用逗号可以分割多个语句，一般可以在声明多个变量时使用
- var a,b,c  //声明多个变量

js中，运算符也有优先级

如：先乘除，后加减

![image-20210826165739066](https://github.com/Web-Wss/notes/blob/main/JavaScript/image-20210826165739066.png)

# 代码块：

- 我们的程序是由一条一条语句构成的

- 语句是按照自上向下的顺序一条一条执行的

- 在js中可以使用{}来为语句进行分组

- 同一个{}中的语句我们称为一组语句

- 它们要么都执行，要么都不执行

- 一个{}中的语句我们也称为一个代码块

- 在代码块后就不用再编写分号了

- js中的代码块，只具有分组作用，没有其他的用途

# prompt：

- prompt()可以弹出一个提示框，该提示框中会带有一个文本框
- 用户可以在文本框中输入一段内容，该内容需要一个字符串作为参数
- 用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容

# 流程控制语句：

- js中的程序时从上到下一行一行执行的
- 通过流程控制语句可以控制程序执行流程
  - 使程序可以根据一定的条件来选择执行
- 语句的分类：
  - 条件判断语句
  - 条件分支语句
  - 循环语句

## 条件判断语句：

- 使用条件判断语句可以在执行某个语句之前就进行判断

  - 如果条件成立才会执行语句，条件不成立则语句不执行

- if语句：

  - 语法一：

    - if(条件表达式)

      语句

    - if语句在执行前，会先对条件表达式进行求值判断

    - 如果条件表达式的值为true，则执行if语句

    - 如果条件表达式的值为false，则不会执行if语句

  - 语法二：

    - if(条件表达式){

      ​	语句...

      }else{

      ​	语句...

      }

    - if...else...语句：当该语句执行时，会对if条件表达式进行求值判断

  - 语法三：

    - if(条件表达式){

      语句...

      }else if(条件表达式){

      语句...

      }

## 条件分支语句：

条件分支语句也叫switch语句

switch...case...语句

- 在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较
- 如果为true，则从当前case处开始执行代码
- 使用break来退出switch语句

## while循环：

语句：

`while(条件表达式){

  语句...

 }`

先对while表达式进行求值判断

如果值为true，则执行循环体

循环体执行完毕后，继续对表达式进行判断

如果为true，则继续执行循环体，以此类推

如果值为false，则终止循环

可以使用break来终止循环

## for循环：

在for循环中，为我们提供了专门的位置用来放三个表达式：

- 初始化表达式
- 条件表达式
- 更新表达式

for语法：

for(初始化表达式;条件表达式;更新表达式){

​	语句...

}

for循环的三个部分都可以省略，也可以在外部写

- 如果不写任何表达式，只写两个;;
- 此时循环是一个死循环会一直执行下去，慎用！

# break和continue：

break关键字可以用来退出switch循环或循环语句

continue关键字可以跳过当次循环

- 同样continue也是默认只对离他最近的循环起作用

# 对象：

对象的分类：

- 内建对象：
  - 由ES标准中定义的对象，在任何的ES的实现中都可以使用
  - 如：Math、String、Number、Boolean、Function、Object......
- 宿主对象：
  - 由js的运行环境提供的对象，目前来将主要指由浏览器提供的对象
  - 如：BOM、DOM
- 自定义对象：
  - 由开发人员自己创建的对象

对象的属性值可以是任何的数据类型，也可以是个函数

函数也可以称为对象的属性

## 枚举对象中的属性：

使用for...in 语句

语法：

for (var 变量 in 对象){

}

for...in语句，对象中有几个属性，循环体就会执行几次

```javascript
var obj = {
  name: "孙悟空",
  age: 18,
  gender: "男",
  address: "花果山"
 }
 for (var n in obj) {
  console.log(n);
  console.log(obj[n]);
 }
```

## 创建对象：

- 使用new关键字调用函数，是构造函数constructor
- 构造函数是专门用来创建对象的函数
- 使用typeof检查一个对象时，会返回object

在对象中保存的值称为属性

向对象添加属性：

- 语法：对象.属性名 = 属性值

读取对象属性：

- 语法：对象.属性名

如果要使用特殊的属性名，不能采用 . 的方式来操作

需要另一种方式：

​	语法：对象["属性名"] = 属性值

读取时也需要采用这种方式

使用[]这种形式取操作属性，更加灵活

在[]中可以直接传递一个变量，这样变量值是多少就会读那个属性

属性值：

- js对象的属性值，可以是任意的数据类型

in运算符：

- 通过该运算符可以检查一个对象中是否含有指定的属性
- 如果有则返回true，反之返回false

语法：“属性名” in 对象

# 基本数据类型和引用数据类型：

基本数据类型：

- js中的变量都是保存到栈内存中的

- 值与值之间是独立存在的，修改一个变量不会影响其他变量

引用数据类型（对象）：

- 对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间
- 而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当改变一个值的时候，另一个也会收到影响
- 当比较两个基本数据类型时，就是比较值
- 当比较两个引用数据类型时，比较的是对象的地址

# 对象字面量：

使用字面量来创建一个对象：

- 使用对象字面量，可以在创建对象时，直接指定对象中的属性
- 语法：
  - var obj = {属性名:属性值，属性名:属性值}
  - 对象字面量的属性名可以加引号也可以不加，不建议加

# 函数的简介：

- 函数也是一个对象

- 函数中可以封装一个功能，需要的时候可以执行这些功能

- 函数中可以保存一些代码在需要的时候调用

- 使用typeof检查一个函数对象时，会返回function

使用函数声明来创建一个函数：

function 函数名([形参1，形参2...]){

}

# 函数的参数：

可以在函数的（）中来指定一个或多个形参（形式参数）

多个参数之间用逗号隔开，声明形参就相当于在函数内部声明了对应的变量，但不赋值

在调用函数时，可以在（）中指定实参（实际参数）

实参可以是任何值

实参将会赋值给函数中对应的形参

调用函数时，解析器不会检查实参的数量

多余的实参不会被赋值，如果实参少于形参数量，则没有的将时undefined

# 函数的返回值：

使用return 来设置函数的返回值

语法：

return  值

return后的值将会作为函数的执行结果返回

# 返回值的类型：

返回值可以是任意的数据类型

也可以是一个对象

# 立即执行函数：

```javascript
(function () {
  alert('我是立即执行函数');
 })();
```

# 作用域：

作用域：

- 作用域指一个变量作用的范围

- 在js中一共两种作用域：

  - 全局作用域

  直接编写在script标签中的js代码，都在全局作用域

  全局作用域在也页面打开时创建，在页面关闭时销毁

  在全局作用域中有一个全局对象window，我们可以直接使用

  创建的变量都会作为window对象的属性保存

  创建的函数都会作为window对象的方法保存

  - 函数作用域

  调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁

  每调用一次函数就会创建一个新的函数作用域，它们之间时互相独立的

  在函数作用域中可以访问到全局作用域

  在函数作用域操作一个变量时，它会现在自己的作用域内找，然后往外找

# 声明提前：

## 变量的声明提前：

使用var关键字声明的变量，会在所有的代码执行之前被声明

但是如果声明变量时不使用var关键字，则变量不会被声明提前

## 函数的声明提前：

使用函数声明形式创建函数function 函数(){}

它会在所有的代码执行之前就被创建

注意：使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

# this：

解析器在调用函数每次都会向函数内部传递一个隐含的参数

这个隐含的参数就是this，this指向的是一个对象

这个对象我们称为函数执行上下文对象

根据函数的调用方式不同，this会指向不同的对象

1. 以函数的形式调用时，this永远是window
2. 以方法形式调用时，this就是调用方法的那个对象

# 使用工厂方法创建对象：

```javascript
function createPerson(name, age, gender) {
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  obj.gender = gender;
  obj.sayName = function () {
   alert(this.name);
  }
  return obj;
 }
 var obj1 = createPerson("猪八戒", 20, "男");
 console.log(obj1);
```

# 构造函数：

构造函数就是一个普通的函数，创建方式和普通函数没有区别

不同的是构造函数习惯上首字母大写

构造函数和普通函数的区别就是调用方式不同

普通函数是直接调用，而构造函数需要使用new关键字来调用

- 构造函数的执行流程
  1. 立即创建一个新的对象
  2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象
  3. 逐行执行函数中的代码
  4. 将新建的对象作用返回值返回

```javascript
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  this.syaName = function () {
   alert(this.name);
  }
 }
 var per = new Person("孙悟空", 20, "男");
 console.log(per);
```

使用instanceof可以检查一个对象是否是一个类的实例

语法：

对象  instanceof  构造函数

如果是，则返回true，否则返回false

# 原型对象：

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype

这个属性对应着一个对象，这个对象就是原型对象

如果函数作为普通函数调用prototype没有任何作用

当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性

指向该构造函数的原型对象，我们可以通过`__proto__`来访问该属性

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象

我们可以将对象中共有的内容，同意设置到原型对象中

- 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
- 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性

# 数组：

数据（Array）

- 数组也是一个对象
- 它和我们普通对象功能类似，也是用来存储一些值的
- 不同的是普通对象是使用字符串作为属性名，而数组是使用数字来作为索引操作元素的
- 索引，从0开始的整数就是索引
- 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据

创建数组：

var arr = new Array()

向数组中添加元素：

- 数组[索引] = 值

读取数组中的值：

- 数组[索引]

如果读取不存在的索引，返回undefined

获取数组的长度：

- 数组.length

如果修改length大于原长度，则多余部分会空出来

如果修改length小于原长度，则多余部分会删除

# 数组字面量：

var arr = [];

使用字面量创建数组时，可以在创建时就指定数组中的元素

- var arr = [1,2,3,4,5];

- 创建一个数组中只有一个元素10

arr = [10];

- 创建一个长度为10的数组

arr = new Array(10);

- 数组中的元素可以是任意的数据类型

arr = ["hello",1,true,null,undefined];

# 数组的方法：

- push()：

该方法可以向数组的末尾添加一个或多个元素，并返回数组新的长度

该方法会将数组新的长度作为返回值返回

- pop()：

该方法可以删除数组的最后一个元素

该方法会将被删除的元素作为返回值返回

- unshift()：

该方法向数组开头添加一个或多个元素，并返回新的数组长度

向前面插入元素以后，其他元素的索引会依次调整

- shift()：

可以删除数组第一个元素，将删除的元素作为返回值

- concat()：

可以连接两个或多个数组，并将新的数组返回

该方法不会对原数组产生影响

- join()

该方法可以将数组转换为一个字符串

该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回

在join()中可以指定一个字符串作为参数的连接符，这个参数将会成为数组元素连接符

如果不使用连接符，则默认使用逗号连接

- reverse()：

该方法用来翻转数组（前边的去后边，后边的去前边）

该方法会直接修改原数组

- sort()：

可以用来对数组中的元素进行排序

也会影响原数组，默认会按照Unicode编码进行排序

我们可以在sort()中添加一个回调函数

回调函数中需要定义两个形参

浏览器会根据回调函数的返回值来决定元素的顺序

如果返回一个大于0的值，则元素会交换位置

如果返回一个小于0的值，则元素位置不变

如果返回一个0，则认为两个元素相等，也不交换位置

对数字排序：

```javascript
var arr = [5, 4, 11];
 arr.sort(function (a, b) {
  // if (a > b) {
  //  return 1;
  // } else if (a < b) {
  //  return -1;
  // } else {
  //  return 0;
  // }
  return a - b;//升序
  return b - a;//降序
 });
 console.log(arr);
```

# 数组的遍历：

```javascript
var arr = ["孙悟空", "猪八戒", "沙和尚"];
 for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
 }
 console.log(arr.length);
```

# forEach()：

一般我们都是使用for循环去遍历数组

js中还为我们提供了一个方法，用来遍历数组

forEach()

- 只支持ie8以上的浏览器

forEach()方法需要一个函数作为参数

像这种函数，由我们创建但是不由我们调用的，我们称为回调函数

数组中有几个元素函数就会执行几次，每次执行，浏览器会将遍历到的元素

以实参的形式传递进来，我们可以定义形参，来读取这些内容

- 浏览器会在回调函数中传递三个参数：
  - 第一个参数，就是当前正在遍历的元素
  - 第二个参数，就是当前正在遍历的元素的索引
  - 第三个参数，就是当前正在遍历的数组

```javascript
var arr = ["孙悟空", "猪八戒", "沙和尚"];
 arr.forEach(function (value, item, c) {
  console.log(value + '--' + item + '--' + c);
 })
```

# splice()和slice():

- splice():

可以用于删除数组中的指定元素

使用splice()会影响到元素数组，会将指定元素从原数组中删除

并将被删除的元素作为返回值返回

参数：

1. 第一个，表示开始位置的索引，包含开始索引
2. 第二个，表示删除的数量
3. 第三个及以后，可以传递一些新的元素，这些元素会自动插入到开始位置索引前

- slice():

可以用来从数组提取指定元素

该方法不会改变数组，而是将截取到的元素封装到一个新数组中返回

参数：

1. 截取开始的位置索引，包含开始索引
2. 截取结束的位置索引，不包含结束索引

第二个参数可以省略不写，此时会截取从开始索引往后的所有元素

索引可以传递一个负值，如果传递一个负值，则从后往前计算

-1：倒数第一个

-2：倒数第二个

# call()和apply()：

这两个方法都是函数对象的方法，需要通过函数对象来调用

当对函数调用call()和apply()都会调用函数执行

在调用call()和apply()可以将一个对象指定为第一个参数

此时这个对象将会称为函数执行时的this

call()方法可以将实参在对象之后依次传递

apply()方法需要将实参封装到一个数组中统一传递

this的情况：

1. 以函数形式调用时，this永远都是window
2. 以方法的形式调用时，this是调用方法的对象
3. 以构造函数的形式调用时，this是指定的那个对象

# arguments：

在调用函数时，浏览器每次都会传递两个隐含的参数

1. 函数的上下文对象this
2. 封装实参的对象arguments

arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度

在调用函数时，我i们所传递的实参都会在arguments中保存

arguments.length可以用来获取实参的长度

它里面有一个属性callee

这个属性对应一个函数对象，就是当前正在指向的函数对象

# Date对象：

在js中使用Date对象来表示一个时间

创建一个Date对象

如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行时间

创建一个指定时间对象

需要在构造函数中传递一个表示时间的字符串作为参数

日期格式： 月份/日/年 时:分:秒

- getDate()：获取一个月中的某一天
- getDay()：获取是周几，范围0-6，0表示周日，1表示周一
- getMonth()：获取月份，范围0-11，0表示1月，11表示12月
- getFullYear()：获取年份
- getHours()：获取小时
- getMinutes()：获取分
- getSeconds()：获取秒
- getMilliseconds()：获取毫秒
- getTime()：获取当前时间的时间戳，返回1970年1月1日至今的毫秒数

# Math对象：

Math和其他对象不同，他不是一个构造函数

它属于一个工具类不用创建对象，它里面封装了数学运算相关的属性和方法

如：Math.PI：表示圆周率

- abs(x)：可以用来计算一个数的绝对值
- ceil(x)：对数进行上舍入
- floor(x)：对数进行下舍入
- max(x,y)：返回x和y中最高值
- min(x,y)：返回x和y中最低值
- pow(x,y)：返回x的y次幂
- random()：返回0-1的随机数
- round(x)：把数四舍五入为最接近的整数

# 包装类：

在js中我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象

String()：

​	可以将基本数据类型字符串转换为String对象

Number()：

​	可以将基本数据类型数字转换为Number对象

Boolean()：

​	可以将基本数据类型布尔值转换为Boolean对象

# 字符串的方法：

在底层字符串是以字符数组的形式保存的

length：可以用来获取字符串的长度

- charAt()：可以返回字符串中指定位置的字符，根据索引获取字符
- charCodeAt()：获取指定位置字符的unicode编码
- fromCharCode()：可以根据字符编码去获取字符
- concat()：可以用来连接两个或多个字符串
- indexOf()：可以检索一个字符串中是否含有指定内容
  - 如果有，则返回第一次出现的索引
  - 如果没有，则返回-1
  - 可以指定第二个参数，指定开始查找的位置
- lastIndexOf()：跟indexOf()一样，不同的是从后往前找
  - 也可以指定开始查找的位置
- slice()：可以从字符串中截取指定的内容
  - 不会影响原字符串，而是将截取的内容返回
  - 第一个参数是开始位置的索引（包括i开始位置）
  - 第二个参数是结束位置的索引（不包括结束位置）
  - 如果省略第二个参数，则截取后面所有
  - 可以传递一个负数作为参数，负数的话将会从后边计算
- substring()：可以用来截取一个字符串
  - 第一个参数是开始位置的索引（包括i开始位置）
  - 第二个参数是结束位置的索引（不包括结束位置）
  - 不同的是这个方法不能接受负值，默认使用0
  - 如果第二个参数小于第一个，则自动调整参数位置
- substr()：截取字符串
  - 第一个参数开始位置索引
  - 第二个是截取的长度
- split()：可以将一个字符串拆分为一个数组
  - 需要一个字符串作为参数，将会根据该字符串去拆分数组
- toLowerCase()：将字符串转为小写
- toUpperCase()：将字符串转为大写

# 正则表达式：

正则表达式用于定义一些字符串的规则

创建正则表达式的对象

语法：

```javascript
var 变量 = new RegExp("正则表达式","匹配模式");
```

在构造函数中可以传递一个匹配模式

- i：忽略大小写
- g：全局匹配模式

正则表达式的方法：

test()

- 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则
- 如果符合则返回true，否则返回false

## 语法：

使用字面量来创建正则表达式

语法：

```javascript
var 变量 = /正则表达式/匹配模式
```

使用字面量创建更加简单

使用构造函数创建更加灵活

- 使用 | 表示或者的意思
  - 检查字符串中是否有a或b
    - reg = /a | b/;
- 使用 [ ] 也是或的关系
  - [ab] == a | b
  - [a-z]：任意小写字母
  - [A-Z]：任意大写字母
  - [A-z]：任意字母
  - [0-9]：任意数字
- 检查一个字符串中是否含有abc或adc或aec
  - reg = /a[bde]c/;
- [^  ]除了
- 量词：通过量词可以设置一个内容出现的次数
  - 量词只对它前面的一个内容起作用
  - {n} ：出现n次
  - {m,n}：出现m-n次
  - {m,}：出现m次以上
  - +：至少一个，相当于{1,}
  - *：0个或多个，相当于{0,}
  - ?：0个或一个，相当于{0,1}
  - ^：表示开头：/^a/：匹配开头a
  - $：表示结尾：/a$/：匹配结尾a
- 检查一个字符串中是否含有 . 
- . 表示任意字符
- 在正则表达式中使用\作为转义字符
- \ . 来表示 .
- \ \ 来表示 \
- \w：任意字母、数字、下划线：[A-z0-9_]
- \W：除了字母、数字、下划线：`[^A-z0-9_]`
- \d：任意的数字：[0-9]
- \D：除了数字：`[^0-9]`
- \s：空格
- \S：除了空格
- \b：单词边界
- \B：除了单词边界

去除开头和结尾的空格：

`str.replace(/^\s*|\s*$/g,"");`

## 字符串和正则相关的方法：

- split()：把字符串分割为字符串数组
  - 这个方法不指定全局，也可以全部检索

```javascript
var str = "1a2b3c4d5e6f7g";
var result = str.split(/[A-z]/);
console.log(result);
```

- search()：可以搜索字符串中是否含有指定内容
  - 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1
  - 它可以接受一个正则表达式做为参数，然后根据正则表达式去检索字符串
  - search()只会查找第一个，即使设置全局也没用

- match()：可以根据正则表达式，从一个字符串中将符合条件的内容提取出来

  - 默认情况下match只会找到第一个符合要求的内容，之后就会停止检索
  - 我们可以设置正则表达式为全局模式，这样就会匹配所有内容
  - match()会将匹配到的内容封装到一个数组中返回，即使只查到一个结果

- replace()：可以将字符串中指定内容替换为新的内容

  - 参数
    - 第一个参数，被替换的内容，可以接受正则表达式
    - 第二个参数，新的内容

  默认只会替换第一个

# DOM：

Document Object Model 文档对象模型

js中通过DOM来HTML文档进行操作

- 文档：表示的就是整个HTML网页文档
- 对象：表示将网页中的每一个部分转换为了一个对象
- 模型：表示对象之间的关系，这样方便我们获取对象

节点：网页中的每一个部分都可以称为一个节点

- 标签我们称为元素节点
- 属性我们称为属性节点
- 文本我们称为文本节点
- 文档称为文档节点

# 事件：

事件就是文档或浏览器窗口中发生的一些特定的交互瞬间

onload事件会在整个页面加载完毕后才触发

为window绑定一个onload事件

```javascript
window.onload = function(){
alert("hello");
}
```

# 文档的加载：

浏览器加载一个页面时，是按照自上向下的顺序执行的

读取一行就运行一行

将js代码编写到页面下面就是为了页面加载完毕后再执行js代码

# DOM查询：

获取元素节点

- getElementById()：通过id属性获取一个元素的节点对象
- getElementsByClassName()：通过class属性获取一组元素节点对象
- getElementsByTagName()：通过标签名获取一组元素的节点对象
- getElementsByName()：通过name属性获取一组元素节点对象

获取元素节点的子节点

- getElementsByTagName()：方法，返回当前节点的指定标签名后代节点
- childNodes：属性，表示当前节点的所有子节点
- firstChild：属性，表示当前节点的第一个子节点
- lastChild：属性，表示当前节点的最后一个子节点

获取父节点和兄弟节点

- parentNode：属性，表示当前节点的父元素
- previousSibling：属性，表示当前节点的前一个兄弟节点
- nextSibling：属性，表示当前节点的后一个兄弟节点

document.all：代表页面中所有的元素

document.querySelector()：需要一个选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象

document.querySelectorAll()：用法跟document.querySelector()类似，不同的是它会将符合条件的元素封装到一个数组中返回

# DOM增删改：

创建元素节点：

- createElement()

创建文本节点：

- createTextNode()

向父节点添加子节点：

- 父节点.appendChild(子节点);

可以在指定的子节点前插入新的子节点

- 父节点.insert Before(新节点，旧节点);

可以使用指定的子节点替换已有的子节点

- 父节点.replaceChild(新节点，旧节点);

可以删除一个子节点

- 父节点.removeChild(子节点);
- 子节点.parentNode.removeChild(子节点);

使用inner HTML也可以完成DOM的增删改的相关操作

- 创建一个li标签：var li = document.createElement("li");
- 向li中设置文本：li.innerHTML = "文本"
- 将li添加到city中：city.appendChild(li);

# 使用DOM操作css：

- 通过js修改元素的样式

语法：

元素.style.样式名 = 样式值

注意：如果css的样式名中有 - 

这种名称在js中是不合法的，要将其修改为驼峰命名法

我们通过style属性设置的样式都是内联样式

- 通过js读取元素的样式

语法：

元素.style.样式名

注意：通过style属性读取的是内联样式

## 获取元素的样式：

语法：

元素.currentStyle.样式名

它可以用来读取当前元素正在显示的样式

- currentStyle只有IE支持

在其他浏览器中可以使用：

getComputedStyle()这个方法来获取元素当前的样式

这个方法是window的方法，可以直接使用

需要两个参数：

1. 第一个：要获取样式的元素
2. 第二个：可以传递一个伪元素，一般都传null

该方法会返回一个对象，对象中封装了当前元素对应的样式

可以通过对象.样式名的方法来读取样式

如果获取的样式没有设置，则会获得到一个真是的值，而不是默认值

## 其他样式操作的属性：

clientWidth

clientHeight

- 这两个属性可以获取元素的可见宽度和高度
- 这些属性都是不带px的，返回都是一个数字，可以直接进行计算
- 会获取元素宽度和高度，包括内容区和内边距
- 这些属性都是只读的，不能修改

offsetWidth

offsetHeight

- 获取元素的整个宽度和高度，包括内容区、内边距和边框

offsetParent

- 可以用来获取当前元素的定位父元素
- 会获取到离当前元素最近的开启了定位的祖先元素
  - 如果所有的祖先元素都没开启定位，则返回body

offsetLeft

- 当前元素相对于其定位元素的水平偏移量

offsetTop

- 当前元素相对于其定位元素的垂直偏移量

scrollWidth

scrollHeight

- 可以获取元素整个滚动区域的高度和高度

scrollLeft

- 可以获取水平滚动条滚动的距离

scrollTop

- 可以获取垂直滚动条滚动的距离

当满足scrollHeight - scrollTop == clientHeight

- 说明垂直滚动条滚动到底了

当满足scrollWidth - scrollLeft == clientWidth

- 说明水平滚动条滚动到底了

# 事件对象：

clientX：可以获取鼠标指针的水平坐标

clientY：可以获取鼠标指针的垂直坐标

# 事件的冒泡：

- 所谓的冒泡指的就是事件向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发
- 如果不希望发生事件冒泡可以通过事件对象来取消冒泡

```javascript
box.onclick = function(event){
event = event || window.event;
event.cancelBubble = true;
}
```

# 事件的委派：

我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的

我们可以尝试将其绑定给元素的共同祖先元素

- 事件的委派
  - 指将事件统一绑定给元素的共同祖先元素，这样后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件
  - 事件委派是利用了冒泡，通过委派可以减少事件绑定次数，提高程序性能

event中的target表示的触发事件的对象

# 事件的绑定：

使用 对象.事件 = 函数  的形式绑定响应函数

它只能同时为一个元素绑定一个事件绑定一个响应

不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的

addEventListener()

- 通过这个方法也可以为元素绑定响应函数
- 参数
  1. 事件的字符串，不要on
  2. 回调函数，当事件触发时该函数会被调用
  3. 是否在捕获阶段触发事件，需要一个布尔值，一般都传false

使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数

这样当事件被触发时，响应函数将会按照函数的绑定顺序执行

注意：这个方法不支持IE8以下浏览器

在IE8中可以使用attachEvent()来绑定事件

参数：

1. 事件的字符串，不要on
2. 回调函数

后绑定先执行，执行顺序和addEventListener()相反

# 滚轮的事件：

- onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性

- 在火狐中需要使用DOMmouseScroll来绑定滚动事件
  - 注意：该事件需要通过addEventListener()函数来绑定

- event.wheelDelta 可以获取鼠标滚轮滚动的方向
  - 向上滚是  120
  - 向下滚是 -120

- 在火狐中使用event.detail来获取滚动方向
  - 向上滚 -3
  - 向下滚  3

# 键盘的事件：

- onkeydown：
  - 按键被按下
  - 如果按键一直按着某个按键不松，则事件会一直触发
  - 当onkeydown连续触发时，第一次和第二次之间间隔会稍长，防止误操作

- onkeyup：
  - 按键被松开

键盘事件一般都会绑定给一些可以获取焦点的对象或document

可以通过keyCode来获取按键的编码

除了keyCode，事件对象中还提供了几个属性

altKey

ctrlKey

shiftKey

- 这三个用来判断alt ctrl和shift是否被按下，如果按下，返回true，否则返回false

# BOM：

浏览器对象模型

BOM可以使我们通过js来操作浏览器

在BOM中为我们提供了一组对象，用来完成对浏览器的操作

BOM对象：

- Window：代表的使整个浏览器的窗口，同时window也是网页中的全局对象
- Navigator：代表当前浏览器的信息，通过该对象可以来识别不同的浏览器
- Location：代表当前浏览器的地址栏信息，通过Location可以获取地址信息，或者操作浏览器跳转页面
- History：代表浏览器的历史纪录，可以通过该对象来操作浏览器历史记录，由于隐私原因，该对象不能获取到具体历史记录，只能操作浏览器向前向后
- Screen：代表用户的屏幕信息，通过该对象可以获取到用户的显示器相关信息

这些BOM对象在浏览器中都是作为window对象的属性来保存的

可以通过window对象来使用，也可以直接使用

## Navigator：

代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器

由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了

一般我们只会使用userAgent来判断浏览器的信息

userAgent是一个字符串，这个字符串中包含有用来描述浏览器的信息的内容

不同的浏览器会有不同的userAgent

```javascript
var ua = navigator.userAgent;
 if (/firefox/i.test(ua)) {
  alert("你是火狐");
 } else if (/chorome/i.test(ua)) {
  alert("你是谷歌");
 } else if (/msie/i.test(us)) {
  alert("你是ie");
 } else if ("ActiveXObject" in window) {
  alert("你是IE11");
 }
```

## History：

可以用来操作浏览器向前或向后

length属性可以获取到当成访问的链接数量

- back()
  - 可以用来回退到上一个页面，作用和浏览器的退回按钮功能一样
- forward()
  - 可以跳转到下一个页面，作用和浏览器的前进按钮功能一样
- go()
  - 可以用来跳转到指定页面
  - 他需要一个整数作为参数
    - 1，表示向前跳转一个页面，相当于forward
    - 2，表示向前跳转两个页面
    - -1，表示向后跳转一个页面
    - -2，表示向后跳转两个页面

## Location：

该对象中封装了浏览器的地址栏信息

如果直接打印location，则可以获取地址栏的信息

如果直接将location属性修改为一个完整的路径或相对路径，则页面会跳转到该路径

- assign()
  - 用来跳转到其他页面，作用和直接修改location一样
- reload()
  - 重新加载当前页面，作用和刷新一样
  - 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面
- replace()
  - 可以使用新的页面替换当前页面
  - 不会生成历史记录，不能回退

# 定时器：

setInterval()

- 定时调用
- 可以将一个函数，每隔一段时间执行一次
- 参数
  - 第一个，回调函数，该函数会每隔一段时间被调用一次
  - 第二个，每次调用间隔的时间，单位毫秒
- 返回值：返回一个Number类型的数据
- clearInterval()可以用来关闭一个定时器

`  <div id="count"></div>`

```javascript
var count = document.getElementById("count");
 var num = 1;
 var timer = setInterval(function () {
  count.innerHTML = num++;
  if (num == 10) {
   clearInterval(timer);
  }
 }, 100);
```

# 延时调用：

setTimeout()

- 延时调用一个函数不马上执行，而是隔一段时间再执行，而且只会执行一次
- 用法和setInterval()一样

# 类的操作：

通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面

这样的执行性能是比较差的，而且这种形式当我们要修改多个样式时，不方便

- 我们可以修改class属性来间接修改样式 

```javascript
/**
 * obj:制定元素
 * cn:对应类名
 **/
//定义一个函数，来向一个元素添加类
            function addClass(obj,cn){
                if(!hasClass(obj,cn))
                {
                    obj.className+=" "+cn;
                }
            }
            //定义一个函数判断一个元素有没有这个类
            function hasClass(obj,cn){
                //创建一个正则表达式
                var reg=new RegExp("\\b"+cn+"\\b");
                return reg.test(obj.className)
            }
            //定义一个函数来删除对应元素中的类
            function removeClass(obj,cn){
                //创建一个正则表达式
                var reg=new RegExp("\\b "+cn+"\\b");
                //删除Class
                obj.className=obj.className.replace(reg,"");
            }
            //定义一个函数来切换一个类
            function toggleClass(obj,cn){
                //判断是否有这个类
                if(hasClass(obj,cn))
                {
                    //如果有则删除
                    removeClass(obj,cn);
                }
                else
                {
                    //没有则添加
                    addClass(obj,cn);
                }
            }
```

# json：

js中的对象只有js自己认识，其他语言都不认识

json就是一个特殊的字符串，这个字符串可以被任意的语言所识别

并且可以转换为任意语言中的对象，json再开发中主要用来数据交互

- JSON

  JavaScript Object Notation  js对象表示法

  JSON和js对象的格式一样，只不过JSON字符串中的属性名必须加双引号

- JSON分类
  1. 对象{}
  2. 数组[]
- JSON中允许的值
  1. 字符串
  2. 数值
  3. 布尔值
  4. null
  5. 对象
  6. 数组

在JSON字符串转为js中的对象

在js中，为我们提供了一个工具类，就叫JSON

这个对象可以帮助我们将一个JSON转换为js对象，也可以将一个js对象转换为JSON

- json-->js对象
  - JSON.parse()
    - 可以将JSON字符串转换为js对象
    - 它需要一个JSON字符串作为参数，会将该字符串转为js对象

- js对象-->json
  - JSON.stringify()
    - 可以将一个js对象转换为JSON字符串
    - 需要一个js对象作为参数，会返回一个JSON字符串

- eval()
  - 这个函数可以用来执行一段字符串形式的js代码，并将执行结果返回
  - 如果使用eval()执行的字符串中含有{}，它会将{}当成是代码块
